---------------------------
class A{
	{
		System.out.print("b1 ");
	}
	public A(){
		System.out.print("b2 ");
	}
}

class B extends A{
	static {
		System.out.print("r1 ");
		}
	public B(){
		System.out.print("r2 ");
		
	}
	{
		System.out.print("r3 ");
	}
	static{
		System.out.print("r4 ");
	}
}

public class Test extends B {
	public static void main(String[] args) {
		System.out.print("pre");
		new Test();
		System.out.print("post");
	}
  
solution:-When we make object of a class 
All static blocks execute first then blocks and constructor.

Blocks and constructor executes (super class block then super class constructor, sub class block then sub class constructor).

Sequence for static blocks is super class first then sub class.

Sequence for blocks is super class first then sub class.
------------------------------------------------------------------------------

Java pass reference as value. passing the object reference, and not the actual object itself. 
Simply reassigning to the parameter used to pass the value into the method will do nothing, 
because the parameter is essentially a local variable.
--------------------------------------------------------
static public class Test  {
	public static void main(String[] args) {
		char c='a';
		switch (c) {
		case 65:
			System.out.println("one");
			break;
		case 'a':
			System.out.println("two");
			break;
		case 3:
			System.out.println("three");
			break;
		}
		
	}
}
can't make  Outer class static.. Outer class can only declare public , abstract and final.
Illegal modifier for the class Test; only public, abstract & final are permitted.

--------------------------------------------------------
 public class Test  {
	static int a ;
	public static void main(String[] args) {
		System.out.println("one");
		call(1);
	}
	public static void call(int a ){
		this.a=10;
		System.out.println("two "+a);
	}
}

Reason:-
static members are common for all objects, where as ‘this’ refer to a particular object.
so we cant use ‘this’ operator in the static methods.
---------------------------------------------------------------------------------------------
public class Test  {
	public static void main(String[] args) {
		int x = 10;
		x = myMethod(x--);
		System.out.println(x);
	}
	private static int myMethod(final int x) {
		return x--;
    //While compiling the Test class, the compilation error occurs implying that the final parameter x cannot be assigned a value. 
    //Therefore the option B is correct and remaining options are incorrect.
	}
	
}

-----------------------------------------------------------------------------------------
int[] a =new int[0];
		System.out.println(a.length);
--------------------------------------------------
int[] a =new int[3];
		System.out.println(a[0]);
In java, if the array is not initialized at the time of declaration and creation 
then all the elements of the array are initialized to 0 by default.


---------------------------------
016 is an octal number. The prefix 0 indicates that a number is in octal.
---------------
When you pass an array to a method , a reference is sent to it not the copy of array.
-------------------------
 In this question, double[] x = new double[]{1, 2, 3} is equivalent to double[] x = {1, 2, 3};
 -------------------------------
 System.out.println(""=="");
		System.out.println("A"=="A");
		System.out.println("a==A");
    -------------------------------------
 The modulus operator, % returns the remainder of a division operation. 
 It can be applied on floating-point types as well as integer types.
 (This differs from C/C++, in which the % can only be applied on integer types.)
 ------------------------------------------------------
 x *= 3 + 7; is same as x = x * (3 +7) = 5 * (10) = 50 
 because expression on the right side is always placed inside parentheses.
 -------------------------------------------------------
 & <-- verifies both operands
&& <-- stops evaluating if the first operand evaluates to false since the result will be false

(x != 0) & (1/x > 1) <-- this means evaluate (x != 0) then evaluate (1/x > 1) then do the &. the problem is that for x=0 this will throw an exception.

(x != 0) && (1/x > 1) <-- this means evaluate (x != 0) and only if this is true then evaluate (1/x > 1) so if you have x=0 then this is perfectly safe and won't throw any exception if (x != 0) evaluates to false the whole thing directly evaluates to false without evaluating the (1/x > 1).

EDIT:

exprA | exprB <-- this means evaluate exprA then evaluate exprB then do the |.

exprA || exprB <-- this means evaluate exprA and only if this is false then evaluate exprB and do the ||.

-----------------------------------------------------------------------------
The overriding method can throw any unchecked (runtime) exception, regardless of exception thrown by overridden method. 
NullPointerException is RuntimeException so compiler will not complain.
---------------------------------------------------------------------------------------
An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.
-----------------------------------------------------------------------------------------


